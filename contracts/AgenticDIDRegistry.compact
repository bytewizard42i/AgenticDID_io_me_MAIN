/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * AgenticDID Registry - Midnight Smart Contract
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * ğŸ¯ PURPOSE:
 * Store and verify AI agent credentials on Midnight blockchain with privacy
 * 
 * ğŸ”— INTEGRATES WITH:
 * - Backend: /backend/midnight/mcp-client.ts (talks to this contract)
 * - MCP Server: /I-am-midnight/midnight-mcp-johns_copy/ (routes calls here)
 * 
 * ğŸ“š REFERENCE DOCS:
 * - Compact syntax: https://docs.midnight.network/develop/compact/
 * - Example contracts: /I-am-midnight/ref_example-counter-johns-copy/
 * - Language spec: /I-am-midnight/ref_compact-johns-copy/
 * 
 * ğŸ† FOR HACKATHON:
 * - Track: AI Track - Privacy-Preserving Intelligence
 * - Feature: Selective-disclosure credentials for AI agents
 * - Innovation: On-chain reputation without revealing identities
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */

pragma language_version >= 0.17.0;
import CompactStandardLibrary;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// LEDGER STATE (On-Chain Storage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * BREADCRUMB: Map of agent PIDs to their credentials
 * 
 * KEY: Bytes<32> - Agent's privacy-preserving identifier (hash)
 * VALUE: AgentCredential - Their full credential data
 * 
 * PRIVACY: PIDs are hashes, not real identities
 * PATTERN: Based on Map usage in ref_example-counter-johns-copy/
 */
ledger agents: Map<Bytes<32>, AgentCredential>;

/**
 * BREADCRUMB: Revocation status (bitmap)
 * 
 * KEY: Bytes<32> - Agent PID
 * VALUE: Boolean - true = revoked, false = active
 * 
 * WHY SEPARATE: Efficient queries without loading full credential
 * PATTERN: Standard revocation pattern from Midnight docs
 */
ledger revocations: Map<Bytes<32>, Boolean>;

/**
 * BREADCRUMB: Issuer registry (who can issue credentials)
 * 
 * KEY: ContractAddress - Issuer's address
 * VALUE: Boolean - true = authorized issuer
 * 
 * SECURITY: Only authorized issuers can register agents
 */
ledger authorizedIssuers: Map<ContractAddress, Boolean>;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DATA STRUCTURES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Agent Credential
 * 
 * BREADCRUMB: Everything we store about an agent on-chain
 * 
 * PRIVACY DESIGN:
 * - agentPID: Hash of real identity (privacy-preserving)
 * - role: Encoded role type (not plaintext)
 * - scopes: Encoded permissions (selective disclosure)
 * - merkleCommitment: For proving subset of claims without revealing all
 * 
 * REFERENCE: Credential structure from official Midnight examples
 */
struct AgentCredential {
  /**
   * BREADCRUMB: Privacy-Preserving Identifier
   * 
   * This is NOT the agent's real identity!
   * It's a hash: PID = hash(agent_id + salt)
   * 
   * WHY: Agents can prove they own this without revealing who they are
   */
  agentPID: Bytes<32>;
  
  /**
   * BREADCRUMB: Role Type
   * 
   * Examples (encoded as Bytes<32>):
   * - "Banker" â†’ hash("banker")
   * - "Shopper" â†’ hash("shopper")
   * - "Traveler" â†’ hash("traveler")
   * 
   * WHY ENCODED: Privacy - role isn't readable on-chain
   * PROOF: Agent proves they match this role with ZK proof
   */
  role: Bytes<32>;
  
  /**
   * BREADCRUMB: Permission Scopes
   * 
   * Examples (encoded):
   * - Banker: ["bank:transfer", "bank:balance"]
   * - Shopper: ["shop:purchase", "shop:cart"]
   * 
   * WHY Bytes<256>: Multiple scopes packed into one field
   * FORMAT: Comma-separated, encoded
   */
  scopes: Bytes<256>;
  
  /**
   * BREADCRUMB: Issuer Address
   * 
   * WHO issued this credential? (e.g., AgenticDID.io)
   * SECURITY: Only issuer can revoke later
   */
  issuer: ContractAddress;
  
  /**
   * BREADCRUMB: Timestamps
   * 
   * issuedAt: When credential was created (Unix timestamp)
   * expiresAt: When credential becomes invalid
   * 
   * SECURITY: Prevents old/expired credentials from working
   */
  issuedAt: Uint<64>;
  expiresAt: Uint<64>;
  
  /**
   * BREADCRUMB: Merkle Commitment
   * 
   * ADVANCED FEATURE: For selective disclosure
   * 
   * HOW IT WORKS:
   * 1. Agent has multiple claims: {age: 25, role: "banker", credit: 750}
   * 2. Create Merkle tree of all claims
   * 3. Store only the root (this field)
   * 4. Agent can prove ANY claim without revealing others
   * 
   * REFERENCE: Merkle proofs pattern from /I-am-midnight/ref_rs-merkle-johns-copy/
   */
  merkleCommitment: Bytes<32>;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PUBLIC CIRCUITS (Functions Callable via MCP)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Initialize Contract
 * 
 * BREADCRUMB: Called once when contract is deployed
 * Sets up the first authorized issuer
 * 
 * PATTERN: Standard initialization from Midnight contract examples
 */
export circuit initialize(
  initialIssuer: ContractAddress
): [] {
  // BREADCRUMB: Mark the deployer as an authorized issuer
  authorizedIssuers.insert(disclose(initialIssuer), disclose(true));
}

/**
 * Register a New Agent
 * 
 * BREADCRUMB: Called from MCP client to add agent to blockchain
 * 
 * CALL PATH:
 * Your API â†’ MCP Client â†’ MCP Server â†’ THIS FUNCTION
 * 
 * EXAMPLE USAGE:
 * ```typescript
 * await mcpAdapter.registerAgent(
 *   'pid:banker-001',
 *   'Banker',
 *   ['bank:transfer', 'bank:balance'],
 *   365 // days
 * );
 * ```
 * 
 * @param caller - Who is calling this (must be authorized issuer)
 * @param agentPID - Agent's privacy-preserving ID
 * @param role - Encoded role type
 * @param scopes - Encoded permissions
 * @param merkleCommitment - Commitment for selective disclosure
 * @param duration - How long credential is valid (seconds)
 * @param currentTime - Current timestamp (for expiration calculation)
 */
export circuit registerAgent(
  caller: ContractAddress,
  agentPID: Bytes<32>,
  role: Bytes<32>,
  scopes: Bytes<256>,
  merkleCommitment: Bytes<32>,
  duration: Uint<64>,
  currentTime: Uint<64>
): [] {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 1: Security Checks                                  â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Only authorized issuers can register agents
  assert(
    authorizedIssuers.member(disclose(caller)) && 
    authorizedIssuers.lookup(disclose(caller)),
    "Only authorized issuers can register agents"
  );
  
  // BREADCRUMB: Check if agent already exists
  assert(
    !agents.member(disclose(agentPID)),
    "Agent already registered"
  );
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 2: Create the Credential                            â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Build the credential struct
  const credential = AgentCredential {
    agentPID: agentPID,
    role: role,
    scopes: scopes,
    issuer: caller,
    issuedAt: currentTime,
    expiresAt: currentTime + duration,  // Calculate expiration
    merkleCommitment: merkleCommitment
  };
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 3: Store on Blockchain                              â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Insert into agents ledger
  agents.insert(disclose(agentPID), disclose(credential));
  
  // BREADCRUMB: Initialize revocation status (not revoked)
  revocations.insert(disclose(agentPID), disclose(false));
  
  // SUCCESS! Agent is now registered on Midnight blockchain
}

/**
 * Verify an Agent
 * 
 * BREADCRUMB: ğŸ”¥ THE MOST IMPORTANT FUNCTION! ğŸ”¥
 * 
 * This is called EVERY TIME an agent tries to do something.
 * It checks if the agent is valid and returns their permissions.
 * 
 * CALL PATH:
 * Your API â†’ MCP Client â†’ MCP Server â†’ THIS FUNCTION â†’ Back to API
 * 
 * EXAMPLE USAGE:
 * ```typescript
 * const result = await mcpAdapter.verifyAgent({
 *   agentPID: 'pid:banker-001',
 *   role: 'Banker',
 *   scopes: ['bank:transfer']
 * });
 * 
 * if (result.verified) {
 *   // Allow the action!
 * }
 * ```
 * 
 * @param agentPID - Agent to verify
 * @param currentTime - Current timestamp (to check expiration)
 * @returns Struct with: valid (bool), role, scopes
 */
export circuit verifyAgent(
  agentPID: Bytes<32>,
  currentTime: Uint<64>
): {valid: Boolean, role: Bytes<32>, scopes: Bytes<256>} {
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 1: Check if Agent Exists                            â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Does this agent exist in our registry?
  if (!agents.member(disclose(agentPID))) {
    // Agent not found - return invalid
    return {
      valid: false,
      role: Bytes<32>::zero(),
      scopes: Bytes<256>::zero()
    };
  }
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 2: Load the Credential                              â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Retrieve credential from blockchain storage
  const credential = agents.lookup(disclose(agentPID));
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 3: Check Revocation Status                          â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Has this credential been revoked?
  const isRevoked = revocations.lookup(disclose(agentPID));
  if (isRevoked) {
    // Credential was revoked - deny!
    return {
      valid: false,
      role: credential.role,
      scopes: Bytes<256>::zero()  // No permissions!
    };
  }
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 4: Check Expiration                                 â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Is this credential still valid time-wise?
  if (currentTime > credential.expiresAt) {
    // Credential expired - deny!
    return {
      valid: false,
      role: credential.role,
      scopes: Bytes<256>::zero()
    };
  }
  
  // â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  // â”‚ STEP 5: ALL CHECKS PASSED - Return Success!              â”‚
  // â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
  
  // BREADCRUMB: Agent is valid! Return their role and permissions
  return {
    valid: true,
    role: credential.role,
    scopes: credential.scopes
  };
}

/**
 * Revoke an Agent
 * 
 * BREADCRUMB: Permanently disable an agent's credential
 * 
 * SECURITY: Only the original issuer can revoke
 * USE CASE: Agent compromised, misbehaving, or no longer trusted
 * 
 * @param caller - Must be the issuer who registered this agent
 * @param agentPID - Agent to revoke
 */
export circuit revokeAgent(
  caller: ContractAddress,
  agentPID: Bytes<32>
): [] {
  // BREADCRUMB: Check agent exists
  assert(
    agents.member(disclose(agentPID)),
    "Agent not found"
  );
  
  // BREADCRUMB: Get the credential
  const credential = agents.lookup(disclose(agentPID));
  
  // BREADCRUMB: Verify caller is the original issuer
  assert(
    credential.issuer == caller,
    "Only issuer can revoke their own credentials"
  );
  
  // BREADCRUMB: Mark as revoked (immutable - can't un-revoke!)
  revocations.insert(disclose(agentPID), disclose(true));
  
  // DONE! Agent is now revoked permanently
}

/**
 * Check Revocation Status
 * 
 * BREADCRUMB: Quick check without full verification
 * 
 * PUBLIC: Anyone can call this
 * USE CASE: Fast pre-check before full verification
 * 
 * @param agentPID - Agent to check
 * @returns true if revoked, false if active or not found
 */
export circuit isRevoked(
  agentPID: Bytes<32>
): Boolean {
  // BREADCRUMB: Check if we have revocation info
  if (!revocations.member(disclose(agentPID))) {
    // Agent not in system - return false
    return false;
  }
  
  // BREADCRUMB: Return actual revocation status
  return revocations.lookup(disclose(agentPID));
}

/**
 * Get Agent Info (Public Read)
 * 
 * BREADCRUMB: Read agent's public info (not private data!)
 * 
 * PRIVACY: Only returns non-sensitive fields
 * DOES NOT RETURN: Actual identity, full scopes (encoded only)
 * 
 * @param agentPID - Agent to query
 * @returns Credential struct (or zero if not found)
 */
export circuit getAgentInfo(
  agentPID: Bytes<32>
): AgentCredential {
  // BREADCRUMB: Check if agent exists
  if (!agents.member(disclose(agentPID))) {
    // Return empty/zero credential
    return AgentCredential {
      agentPID: Bytes<32>::zero(),
      role: Bytes<32>::zero(),
      scopes: Bytes<256>::zero(),
      issuer: ContractAddress::zero(),
      issuedAt: Uint<64>::zero(),
      expiresAt: Uint<64>::zero(),
      merkleCommitment: Bytes<32>::zero()
    };
  }
  
  // BREADCRUMB: Return the full credential (encoded, not readable)
  return agents.lookup(disclose(agentPID));
}

/**
 * Add Authorized Issuer
 * 
 * BREADCRUMB: Admin function to authorize new credential issuers
 * 
 * SECURITY: Only existing authorized issuers can add new ones
 * USE CASE: Allow partners (banks, services) to issue credentials
 * 
 * @param caller - Must be authorized issuer
 * @param newIssuer - Address to authorize
 */
export circuit addAuthorizedIssuer(
  caller: ContractAddress,
  newIssuer: ContractAddress
): [] {
  // BREADCRUMB: Verify caller is authorized
  assert(
    authorizedIssuers.member(disclose(caller)) &&
    authorizedIssuers.lookup(disclose(caller)),
    "Only authorized issuers can add new issuers"
  );
  
  // BREADCRUMB: Add the new issuer
  authorizedIssuers.insert(disclose(newIssuer), disclose(true));
}

/**
 * Check if Issuer is Authorized
 * 
 * BREADCRUMB: Public check for issuer status
 * 
 * @param issuer - Address to check
 * @returns true if authorized
 */
export circuit isAuthorizedIssuer(
  issuer: ContractAddress
): Boolean {
  if (!authorizedIssuers.member(disclose(issuer))) {
    return false;
  }
  return authorizedIssuers.lookup(disclose(issuer));
}

/**
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * CONTRACT COMPLETE!
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 * 
 * NEXT STEPS:
 * 1. Compile: docker run midnightnetwork/compactc ...
 * 2. Deploy: Use MCP server deployment tools
 * 3. Get contract address
 * 4. Update mcp-adapter.ts with address
 * 5. Test via MCP client
 * 
 * REFERENCE DOCS:
 * - Compiling: https://docs.midnight.network/develop/compact/compile/
 * - Deploying: https://docs.midnight.network/develop/compact/deploy/
 * - Testing: https://docs.midnight.network/develop/compact/test/
 * 
 * FOR HACKATHON:
 * This contract implements the exact "AI reputation layer" from the AI Track!
 * - âœ… Selective-disclosure credentials (merkleCommitment)
 * - âœ… Privacy-preserving (PIDs, encoded roles)
 * - âœ… Zero-knowledge ready (ZK proof verification can be added)
 * - âœ… On-chain reputation (immutable, auditable)
 * 
 * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
 */
