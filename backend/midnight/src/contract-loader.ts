/**
 * Contract Loader
 * 
 * Loads compiled Midnight Compact smart contracts and provides access to their APIs.
 * Contracts are compiled from protocol/contracts/ and loaded from protocol/compiled/
 * 
 * Pattern based on reference-repos/example-counter contract loading
 */

import { readFileSync } from 'fs';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import type { Logger } from 'pino';
import type { MidnightConfig } from './config.js';

/**
 * Contract metadata
 */
export interface ContractMetadata {
  name: string;
  path: string;
  version: string;
  description: string;
}

/**
 * Loaded contract with compiled artifacts
 */
export interface LoadedContract {
  metadata: ContractMetadata;
  contract: any; // Compiled contract instance
  api: any; // Contract API (generated by Compact compiler)
}

/**
 * Available AgenticDID contracts
 */
export enum ContractType {
  AGENTIC_DID_REGISTRY = 'AgenticDIDRegistry',
  CREDENTIAL_VERIFIER = 'CredentialVerifier',
  PROOF_STORAGE = 'ProofStorage',
}

/**
 * Contract loader class
 * 
 * Loads and manages access to compiled Midnight contracts
 */
export class ContractLoader {
  private logger: Logger;
  private contractsPath: string;
  private loadedContracts: Map<ContractType, LoadedContract> = new Map();

  constructor(config: MidnightConfig, logger: Logger) {
    this.logger = logger.child({ component: 'ContractLoader' });
    this.contractsPath = config.contractsPath;
    
    this.logger.info(`Contract loader initialized with path: ${this.contractsPath}`);
  }

  /**
   * Load a specific contract by type
   * 
   * @param contractType - Type of contract to load
   * @returns Loaded contract with API
   */
  async loadContract(contractType: ContractType): Promise<LoadedContract> {
    // Check if already loaded
    if (this.loadedContracts.has(contractType)) {
      this.logger.debug(`Contract ${contractType} already loaded, returning cached version`);
      return this.loadedContracts.get(contractType)!;
    }

    this.logger.info(`Loading contract: ${contractType}`);

    try {
      // Construct paths to compiled artifacts
      const contractPath = this.getContractPath(contractType);
      
      // Load contract artifacts
      // Note: Actual implementation depends on Compact compiler output format
      // This is a placeholder structure based on reference patterns
      const contract = await this.loadContractArtifacts(contractPath);
      
      const loadedContract: LoadedContract = {
        metadata: {
          name: contractType,
          path: contractPath,
          version: '1.0.0',
          description: this.getContractDescription(contractType),
        },
        contract,
        api: contract.api || contract, // Contract API from Compact compiler
      };

      // Cache the loaded contract
      this.loadedContracts.set(contractType, loadedContract);
      
      this.logger.info(`✅ Contract ${contractType} loaded successfully`);
      
      return loadedContract;
    } catch (error) {
      this.logger.error(`Failed to load contract ${contractType}:`, error);
      throw new Error(
        `Contract loading failed for ${contractType}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }

  /**
   * Load all AgenticDID contracts
   * 
   * @returns Map of all loaded contracts
   */
  async loadAllContracts(): Promise<Map<ContractType, LoadedContract>> {
    this.logger.info('Loading all AgenticDID contracts...');

    const contractTypes = [
      ContractType.AGENTIC_DID_REGISTRY,
      ContractType.CREDENTIAL_VERIFIER,
      ContractType.PROOF_STORAGE,
    ];

    for (const contractType of contractTypes) {
      try {
        await this.loadContract(contractType);
      } catch (error) {
        this.logger.warn(`Failed to load ${contractType}, continuing with others...`);
      }
    }

    this.logger.info(`✅ Loaded ${this.loadedContracts.size}/${contractTypes.length} contracts`);

    return this.loadedContracts;
  }

  /**
   * Get a loaded contract by type
   * 
   * @param contractType - Contract type
   * @returns Loaded contract or undefined if not loaded
   */
  getContract(contractType: ContractType): LoadedContract | undefined {
    return this.loadedContracts.get(contractType);
  }

  /**
   * Check if contract is loaded
   * 
   * @param contractType - Contract type
   * @returns True if loaded
   */
  isLoaded(contractType: ContractType): boolean {
    return this.loadedContracts.has(contractType);
  }

  /**
   * Get all loaded contracts
   * 
   * @returns Map of loaded contracts
   */
  getAllContracts(): Map<ContractType, LoadedContract> {
    return this.loadedContracts;
  }

  /**
   * Reload a specific contract (force refresh)
   * 
   * @param contractType - Contract type to reload
   * @returns Reloaded contract
   */
  async reloadContract(contractType: ContractType): Promise<LoadedContract> {
    this.logger.info(`Reloading contract: ${contractType}`);
    
    // Remove from cache
    this.loadedContracts.delete(contractType);
    
    // Load fresh
    return this.loadContract(contractType);
  }

  /**
   * Get contract file path
   * 
   * @param contractType - Contract type
   * @returns Full path to contract directory
   */
  private getContractPath(contractType: ContractType): string {
    // Contracts are organized by name in the compiled directory
    // Example: protocol/compiled/AgenticDIDRegistry/
    return join(this.contractsPath, contractType);
  }

  /**
   * Load contract artifacts from filesystem
   * 
   * @param contractPath - Path to contract directory
   * @returns Loaded contract object
   */
  private async loadContractArtifacts(contractPath: string): Promise<any> {
    this.logger.debug(`Loading artifacts from: ${contractPath}`);

    try {
      // Compact compiler outputs multiple files:
      // - contract.js (or .cjs) - Compiled contract code
      // - contract.d.ts - TypeScript definitions
      // - zkir.json - Zero-knowledge intermediate representation
      // - prover.key, verifier.key - ZK keys
      
      // For now, we import the compiled JS module
      // Actual path depends on Compact compiler output structure
      const contractModulePath = join(contractPath, 'index.js');
      
      this.logger.debug(`Importing contract module: ${contractModulePath}`);
      
      // Dynamic import of compiled contract
      const contractModule = await import(contractModulePath);
      
      return contractModule.default || contractModule;
    } catch (error) {
      this.logger.error(`Failed to load contract artifacts from ${contractPath}:`, error);
      throw error;
    }
  }

  /**
   * Get human-readable contract description
   * 
   * @param contractType - Contract type
   * @returns Description string
   */
  private getContractDescription(contractType: ContractType): string {
    switch (contractType) {
      case ContractType.AGENTIC_DID_REGISTRY:
        return 'Registry of agent DIDs and credential issuers';
      
      case ContractType.CREDENTIAL_VERIFIER:
        return 'Verifies agent credentials and presentations';
      
      case ContractType.PROOF_STORAGE:
        return 'Stores verification proofs on-chain';
      
      default:
        return 'AgenticDID smart contract';
    }
  }

  /**
   * Validate contract structure
   * 
   * Ensures loaded contract has expected methods and properties
   * 
   * @param contract - Loaded contract
   * @param contractType - Expected contract type
   * @returns True if valid
   */
  private validateContract(contract: any, contractType: ContractType): boolean {
    // Basic validation - check for contract API
    if (!contract) {
      this.logger.error(`Contract ${contractType} is null or undefined`);
      return false;
    }

    // Contract-specific validation
    switch (contractType) {
      case ContractType.AGENTIC_DID_REGISTRY:
        // Should have registry methods
        return typeof contract.registerAgent === 'function' ||
               typeof contract.register === 'function';
      
      case ContractType.CREDENTIAL_VERIFIER:
        // Should have verification methods
        return typeof contract.verifyCredential === 'function' ||
               typeof contract.verify === 'function';
      
      case ContractType.PROOF_STORAGE:
        // Should have storage methods
        return typeof contract.storeProof === 'function' ||
               typeof contract.store === 'function';
      
      default:
        // Default: just check it's an object
        return typeof contract === 'object';
    }
  }

  /**
   * Get contract statistics
   * 
   * @returns Object with loading statistics
   */
  getStats(): {
    totalContracts: number;
    loadedContracts: number;
    contractTypes: ContractType[];
  } {
    return {
      totalContracts: Object.keys(ContractType).length / 2, // Enum has key+value
      loadedContracts: this.loadedContracts.size,
      contractTypes: Array.from(this.loadedContracts.keys()),
    };
  }
}

/**
 * Helper function to create and initialize contract loader
 * 
 * @param config - Midnight configuration
 * @param logger - Logger instance
 * @returns Initialized contract loader
 */
export async function createContractLoader(
  config: MidnightConfig,
  logger: Logger
): Promise<ContractLoader> {
  const loader = new ContractLoader(config, logger);
  
  // Optionally pre-load all contracts
  // await loader.loadAllContracts();
  
  return loader;
}
